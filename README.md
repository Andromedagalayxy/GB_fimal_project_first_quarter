Это тренировочный проект

---

This is a training project

![Task photo](images\Task.jpeg)

# Решение 

## Подготовка
Для начала я зашёл в компилятор, создал рабочую папку, инициировал репозиторий **GIT**.

После добавил файл *README.md* и создал свой первый коммит.

Далее были добавлены файлы: *.gitignore* (+ набросок всех необходимых исключений для dotnet от ***GeekBrains***), папка *images* (+ изображение задания) и первые строки, а затем уже и сама папка проекта.

## Работа с кодом
Был создан репозиторий C# и далее я перешёл (мне показалось это удобнее, и я думал, что там есть нормальный дебаггер) в [онлайн-компилятор](https://www.onlinegdb.com/online_csharp_compiler).

Большая часть кода была написана именно там, коммит "Task change 2 (1-st variant)" отображает проведённую работу.

### Основное тело
Задач было несколько (честно признаться учёба у меня пошла не совсем хорошо, и я нормально учится закончил на "Введение в программирование" и начал на "Знакомство с базой данных", пришло уведомление об итоговом проекте, до этого я сделал конспекты и проработал все оставшиеся проблемы до блока "Знакомство с программированием", поэтому код писал по порядку и как попало (благо недоучка с вуза по программированию, хоть что-то помню про циклы, методы и условия :D)):
1. Как то ввести массив с помощью терминала
2. Как то его проверить
3. Перенести нужные по условию переменные в массив
4. Вывести

Звучит просто, но для забывшего все основы недопрограммиста не совсем.

#### 1. **"Как то ввести массив с помощью терминала"**
Ну, хоть что-то я помню, поэтому выводим на экран запрос-сообщение на количество элементов массива. Далее просим поочерёдно вбить их с помощью цикла for от 0 до количества элементов массива. 

#### 2. **"Как то его проверить"**
Тут тоже довольно просто. Тот же цикл с выводом. При работе и проверке и вам удобно, и мне.

#### 3. **"Перенести нужные по условию переменные в массив"**
Тут начинаются дикие тупняки. Сначала догадался упростить себе жизни и загадить код: вычислить по условию длину сообщения по циклу (так как не разрешили пользоваться листами :( ) и счётчиком присвоить искомому массиву размер. Сказано - сделано.
Потом начинается самый дикий тупняк. Массив постоянно выходит за размер, и вроде понимаешь что нужно что-то делать, но не можешь понять как (помогло "утро вечера мудренее", даже форумы не помогли :( ). Вроде бы нужно пройти по размерам старого, но новый идёт по одному месту, потому что оба привязаны к счётчику массива общему. И условие у меня выглядело по другому (уже не помню как). Сначала допёр и написал правильное условие, затем пришла задумка выйти из цикла с помощью счётчика. Если число зарегестрированных добавлений равно (добавли в конце else if чтобы если сразу равно, то цикл прервался) или больше количества элементов в искомом массиве, то выходим из цикла. Но повылазили ошибки, когда в начале, или чередованием нарушаешь условия и снова всё ломалось. 
Затем пришла умная мысль: сделать отдельный счётчик элементов для искомого массива, который идёт дальше если проходит условие. Вот и проблема решена, массив получен.

#### 4. **"Вывести"**
Ну тут всё тоже просто.

## Оптимизация кода
Вспомнил я про методы, хоть и в задании сказано, что не запрещено топором рубить, но хотелось максимум выжать. Что я планировал сделать: 
* Метод для ввода массива исходного
* Метод для вывода обоих массивов
* Метод для подсчёта и структурированной записи нового массива согласно условиям

Из всего получилось только первое :D

В процессе я вспомнил про *static void* и *static с [возвращаемым_типом]*, для вывода годится первый вариант, а для всего остального нужно пользоваться вторым... Грустно...

Понял в процессе, что не успеваю либо в принципе невозможно сделать один на двоих вывод, поэтому оформил два разных.

Метод подсчёта количества элеменнтов я тоже не смог совместить с сортировкой и записью в новый массив, поэтому и их разделил.

Долгое время тупняк был и тут, метод ругался и не возвращал массив. Потом вспомнил, что для возвращаемых массивов тоже нужно прописывать *static string **[]** * к примеру. Работа снова пошла.

Вариант со всеми готовыми методами представлен в коммите Task change 5 (2-nd variant). Забыл написать, что делал я отдельной веткой дважды (общий код и оптимизацию через "Task" и "Task2") и сливал с main (так же забыл написать, что подключил к веб-репозиторию ещё до того, как инициировал C#, благо там все нужные команды сразу после создания репозитория предоставляются, не нужно лезть в конспекты...)

После уже расставил в порядке по Main методы (чтобы удобнее было проверять), переписал названия и вот коммит Task final change (semi-final variant). 

## Блок схема
Каюсь, может быть в том самом пропущенном блоке подробнее работа со схемами представлена, и делается блок схема вперёд кода, но я сегодня всё одел на левую сторону :D 

В скоре допройду блок и исправлюсь...

Поэтому там такие странные блоки по типу *цикл.Lenght* - потому что я не знаю альтернатив... Ну и цикл в цикле, плюс не знаю как обозначать методы... В общем, я старался :D Выглядит внятно, надеюсь...

# ИТОГ
Код - работает, блок-схема - есть, коммитов - достаточно, README.TXT - отредактирован.

Сейчас будет последний коммит, пуш на гит-хаб и я пойду спать. 

# PS 
Спасибо за проверку!



